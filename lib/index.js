// --------------------
// Sequelize definer
// --------------------

// modules
var requireFolderTree = require('require-folder-tree');

// imports
var utils = require('./utils'),
	errors = require('./errors');

// exports
module.exports = function(Sequelize) {
	if (!Sequelize) Sequelize = require('sequelize');
	
	var Utils = Sequelize.Utils,
		_ = Utils._;
	
	utils = utils(Sequelize);
	
	// add custom errors to Sequelize
	errors = errors(Sequelize);
	_.extend(Sequelize, errors);
	_.extend(Sequelize.prototype, errors);
	
	// define a set of models at once
	// input expected in form of a Javascript object with names of the models as keys
	Sequelize.prototype.defineAll = function(definitions, defineOptions) {
		var sequelize = this;
		
		var globalOptions = sequelize.options.define || {};
		
		defineOptions = _.extend({
			primaryKey: 'id',
			primaryKeyType: Sequelize.INTEGER,
			primaryKeyFirst: false,
			autoAssociate: false,
			//onDelete: undefined,
			//onUpdate: undefined,
			//fields: undefined,
			skipFieldsOnThrough: false,
			labels: false,
			freezeTableName: globalOptions.freezeTableName,
			camelThrough: globalOptions.camelThrough
		}, defineOptions || {});
		
		_.defaults(defineOptions, {
			freezeTableName: false,
			camelThrough: false
		});
		
		// prep definitions
		var primaryKeys = {};
		
		definitions = _.mapValues(definitions, function(definition, modelName) {
			return prepOne(modelName, definition);
		});
		
		// process definitions
		var relationshipsOne = [];
		var relationshipsMany = [];
		
		_.forIn(definitions, function(definition, modelName) {
			defineOne(modelName, definition);
		});
		
		// create relationships
		defineRelationships();
		
		// functions
		
		function prepOne(modelName, definition)
		{
			definition = _.clone(definition);
			
			// inherit options from defineOptions (except fields and through-related options)
			var fields = definition.fields = _.clone(definition.fields || {}),
				options = definition.options = _.clone(definition.options || {});
			
			utils.defaultsNoUndef(options, defineOptions);
			['fields', 'associateThrough', 'skipFieldsOnThrough', 'camelThrough'].forEach(function(fieldName) {
				delete options[fieldName];
			});
			
			// add additional fields
			if (defineOptions.fields && !options.skipFields) {
				_.forIn(defineOptions.fields, function(field, fieldName) {
					if (fields[fieldName] !== undefined) return;
					fields[fieldName] = utils.functionValue(_.clone(field), modelName, definition, definitions);
				});
			}
			
			// delete empty fields and set field type where shorthand definition used
			_.forIn(fields, function(field, fieldName) {
				if (!field) {
					delete fields[fieldName];
				} else if (!_.isPlainObject(field)) {
					fields[fieldName] = {type: field};
				}
			});
			
			// find primary key
			var key;
			_.forIn(fields, function(field, fieldName) {
				if (field.primaryKey) {
					key = fieldName;
					return false;
				}
			});
			
			// if no primary key, create primary key column
			if (!key) {
				if (!options.primaryKey) throw new Sequelize.SequelizeDefinerError("Model '" + modelName + "' has no primary key defined");
				
				key = utils.functionValue(options.primaryKey, modelName, definition, definitions);
				var keyField = {type: options.primaryKeyType, allowNull: false, primaryKey: true, autoIncrement: true, _autoGenerated: true};
				
				if (options.primaryKeyFirst) {
					utils.unshift(fields, key, keyField);
				} else {
					fields[key] = keyField;
				}
			}
			
			definition.primaryKey = key;
			primaryKeys[modelName + Utils.uppercaseFirst(key)] = {model: modelName, field: key};
			
			// get table name
			utils.defaultNoUndef(options, 'tableName', options.freezeTableName ? modelName : Utils.pluralize(modelName));
			
			// return definition
			return definition;
		}
		
		function defineOne(modelName, definition)
		{
			var fields = definition.fields,
				options = definition.options;
			
			// populate details of fields
			_.forIn(fields, function(params, fieldName) {
				params = fields[fieldName] = _.clone(params);
				
				var label = fieldName;
				
				// process one-to-one/one-to-many associations
				var reference = params.reference;
				if (reference !== undefined && !reference) {
					delete params.reference;
				} else if (reference || (options.autoAssociate && primaryKeys[fieldName])) {
					// field references another model
					if (reference) {
						if (!definitions[reference]) throw new Sequelize.SequelizeDefinerError("Referenced model '" + reference + "' in field '" + fieldName + "' does not exist");
						
						if (!params.referencesKey) params.referencesKey = definitions[reference].primaryKey;
						
						if (utils.endsWith(fieldName, Utils.uppercaseFirst(params.referencesKey))) {
							var as = fieldName.slice(0, -params.referencesKey.length);
							if (!params.as && as != reference) params.as = as;
							label = params.as || as;
						} else {
							label = reference;
						}
					} else {
						reference = primaryKeys[fieldName].model;
						if (!params.referencesKey) params.referencesKey = primaryKeys[fieldName].field;
						label = reference;
					}
					
					params.references = definitions[reference].options.tableName;
					
					var referenceType = utils.pop(params, 'referenceType') || 'many';
					if (['one', 'many'].indexOf(referenceType) == -1) throw new Sequelize.SequelizeDefinerError("referenceType must be either 'one' or 'many' in '" + modelName + '.' + fieldName + "'");
					
					utils.defaultsNoUndef(params, {
						onDelete: options.onDelete,
						onUpdate: options.onUpdate
					});
					
					var relationshipOptions = {
						modelName1: modelName,
						modelName2: reference,
						foreignKey: fieldName,
						referenceType: 'has' + Utils.uppercaseFirst(referenceType)
					};
					
					utils.extendNoUndef(relationshipOptions, {
						as: params.as,
						asReverse: params.asReverse,
						onDelete: params.onDelete,
						onUpdate: params.onUpdate
					});
					
					// set field type according to referred to field
					var referenceField = definitions[reference].fields[params.referencesKey];
					if (!referenceField) throw new Sequelize.SequelizeDefinerError("referenceKey defined in '" + modelName + '.' + fieldName + "' refers to nonexistent field '" + reference + '.' + params.referencesKey + "'");
					
					params.type = referenceField.type;
					
					// store details in relationships array
					relationshipsOne.push(relationshipOptions);
				}
				
				// create label
				if (options.labels && !params.label) params.label = (label == 'id' ? 'ID' : utils.camelToHuman(label));
			});
			
			// process manyToMany relationships
			if (definition.manyToMany) {
				_.forIn(definition.manyToMany, function(options, modelName2) {
					if (options === true) options = {};
					relationshipsMany.push(_.defaults({modelName1: modelName, modelName2: modelName2}, options));
				});
			}
			
			// define model in sequelize
			var model = sequelize.define(modelName, fields, options);
			
			// done
			return model;
		}
		
		function defineRelationships()
		{
			// define relationships
			var models = sequelize.models;
			
			// define one-to-one/one-to-many relationships
			_.forEach(relationshipsOne, function(options) {
				var model1 = models[utils.pop(options, 'modelName1')],
					model2 = models[utils.pop(options, 'modelName2')];
				
				var asReverse = utils.pop(options, 'asReverse');
				
				var joinOptions = _.clone(options);
				utils.setNoUndef(joinOptions, 'as', asReverse);
				model2[options.referenceType](model1, joinOptions); // NB referenceType = 'hasOne' or 'hasMany'
				
				joinOptions = _.clone(options);
				model1.belongsTo(model2, options);
			});
			
			// define many-to-many relationships
			_.forEach(relationshipsMany, function(options) {
				var modelName1 = utils.pop(options, 'modelName1'),
					modelName2 = utils.pop(options, 'modelName2'),
					model1 = models[modelName1],
					model2 = models[modelName2],
					key1 = definitions[modelName1].primaryKey,
					key2 = definitions[modelName2].primaryKey,
					foreignKey1 = modelName1 + Utils.uppercaseFirst(key1),
					foreignKey2 = modelName2 + Utils.uppercaseFirst(key2);
				
				utils.defaultsNoUndef(options, {
					primaryKeyFirst: defineOptions.primaryKeyFirst,
					associate: defineOptions.associateThrough,
					skipFields: defineOptions.skipFieldsOnThrough,
					labels: defineOptions.labels,
					freezeTableName: defineOptions.freezeTableName,
					camel: defineOptions.camelThrough,
					onDelete: defineOptions.onDelete,
					onUpdate: defineOptions.onUpdate
				});
				
				var throughExisting = false;
				if (options.through) {
					// use defined through table
					options.through = models[options.through];
					
					throughExisting = true;
				} else {
					// make through table
					var fields = {};
					fields[foreignKey1] = {type: definitions[modelName1].fields[key1].type, allowNull: false, reference: null, _autoGenerated: true};
					fields[foreignKey2] = {type: definitions[modelName2].fields[key2].type, allowNull: false, reference: null, _autoGenerated: true};
					
					var modelNameAs = options.as ? Utils.singularize(options.as) : modelName2;
					if (options.camel) modelNameAs = Utils.uppercaseFirst(modelNameAs);
					var modelName = modelName1 + modelNameAs;
					var tableName = options.freezeTableName ? modelName : (Utils.pluralize(modelName1) + Utils.pluralize(modelNameAs));
					
					if (models[modelName]) throw new Sequelize.SequelizeDefinerError("Through model '" + modelName + "' between '" + modelName1 + "' and '" + modelName2 + (options.as ? ' (' + options.as + ')' : '') + "' already exists");
					
					var throughOptions = {
						tableName: tableName,
						labels: false,
						skipFields: options.skipFields
					};
					
					options.through = defineOne(modelName, {fields: fields, options: throughOptions});
				}
				
				var asReverse = utils.pop(options, 'asReverse');
				
				var joinOptions = _.clone(options);
				joinOptions.foreignKey = foreignKey1;
				model1.hasMany(model2, joinOptions);
				
				joinOptions = _.clone(options);
				utils.setNoUndef(joinOptions, 'as', asReverse);
				joinOptions.foreignKey = foreignKey2;
				model2.hasMany(model1, joinOptions);
				
				// move keys to first fields
				var through = options.through;
				if (options.primaryKeyFirst && throughExisting) {
					utils.unshift(through.attributes, foreignKey1, utils.pop(through.attributes, foreignKey1));
					utils.unshift(through.attributes, foreignKey2, utils.pop(through.attributes, foreignKey2));
					utils.unshift(through.tableAttributes, foreignKey1, utils.pop(through.tableAttributes, foreignKey1));
					utils.unshift(through.tableAttributes, foreignKey2, utils.pop(through.tableAttributes, foreignKey2));
				}
				
				// create labels
				if (options.labels) {
					through.attributes[foreignKey1].label = utils.camelToHuman(modelName1);
					through.attributes[foreignKey2].label = utils.camelToHuman(modelName2);
				}
			});
		}
	};
	
	Sequelize.prototype.defineFromFolder = function(path, options) {
		options = _.clone(options || {});
		
		var loadOptions = _.clone(utils.pop(options, 'loadOptions') || {});
		loadOptions.flatten = true;
		
		var definitions = requireFolderTree(path, loadOptions);
		
		return this.defineAll(definitions, options);
	};
	
	return Sequelize;
};
