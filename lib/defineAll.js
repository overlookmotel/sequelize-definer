// --------------------
// Sequelize definer
// Sequelize#defineAll() method
// --------------------

// modules
var _ = require('lodash');

// imports
var utils = require('./utils'),
	patchesFn = require('./patches');

// exports

// define a set of models at once
// input expected:
//   definitions: object with names of the models as keys
//   defineOptions: options object
module.exports = function(definitions, defineOptions) {
	var sequelize = this,
		Sequelize = sequelize.Sequelize,
		Utils = Sequelize.Utils,
		patches = patchesFn(Sequelize);

	var globalOptions = sequelize.options.define || {};

	defineOptions = _.extend({
		primaryKey: 'id',
		primaryKeyAttributes: {},
		primaryKeyFirst: false,
		primaryKeyThrough: false,
		autoAssociate: false,
		associateThrough: false,
		//onDelete: undefined,
		//onUpdate: undefined,
		//fields: undefined,
		skipFieldsOnThrough: false,
		labels: globalOptions.labels || false,
		freezeTableName: globalOptions.freezeTableName || false,
		underscored: globalOptions.underscored || false,
		underscoredAll: globalOptions.underscoredAll || false,
		camelThrough: globalOptions.camelThrough || false
	}, defineOptions || {});

	if (defineOptions.primaryKeyType) {
		defineOptions.primaryKeyAttributes.type = defineOptions.primaryKeyType;
		delete defineOptions.primaryKeyType;
	} else {
		defineOptions.primaryKeyAttributes.type = Sequelize.INTEGER;
	}

	// prep definitions
	var primaryKeys = {};

	definitions = _.mapValues(definitions, function(definition, modelName) {
		return prepOne(modelName, definition);
	});

	// process definitions
	var relationshipsOne = [];
	var relationshipsMany = [];

	_.forIn(definitions, function(definition, modelName) {
		defineOne(modelName, definition);
	});

	// create relationships
	defineRelationships();

	// return sequelize (for chaining)
	return sequelize;

	// ----------
	// functions

	function prepOne(modelName, definition)
	{
		definition = _.clone(definition);

		// inherit options from defineOptions (except fields and through-related options)
		var fields = definition.fields = _.clone(definition.fields || {}),
			options = definition.options = _.clone(definition.options || {});

		utils.defaultsNoUndef(options, defineOptions);
		['fields', 'associateThrough', 'skipFieldsOnThrough', 'camelThrough'].forEach(function(fieldName) {
			delete options[fieldName];
		});

		if (options.primaryKeyType) {
			options.primaryKeyAttributes.type = options.primaryKeyType;
			delete options.primaryKeyType;
		}

		options.primaryKeyAttributes = _.defaults({
			primaryKey: true,
			_autoGenerated: true
		}, options.primaryKeyAttributes, defineOptions.primaryKeyAttributes, {
			allowNull: false
		});

		if ([Sequelize.INTEGER.key, Sequelize.BIGINT.key].indexOf(options.primaryKeyAttributes.type.key) != -1) options.primaryKeyAttributes.autoIncrement = true;
		if (options.primaryKeyAttributes.type.key == Sequelize.UUID.key && !options.primaryKeyAttributes.defaultValue) options.primaryKeyAttributes.defaultValue = Sequelize.UUIDV4;

		// add additional fields
		if (defineOptions.fields && !options.skipFields) {
			_.forIn(defineOptions.fields, function(field, fieldName) {
				if (fields[fieldName] !== undefined) return;
				field = utils.functionValue(field, modelName, definition, definitions);
				if (field instanceof Sequelize.ABSTRACT) field = {type: field};
				fields[fieldName] = _.clone(field);
			});
		}

		// delete empty fields and set field type where shorthand definition used
		_.forIn(fields, function(field, fieldName) {
			if (!field) {
				delete fields[fieldName];
			} else if (!_.isPlainObject(field)) {
				fields[fieldName] = {type: field};
			}
		});

		// find primary key
		var key;
		_.forIn(fields, function(field, fieldName) {
			if (field.primaryKey) {
				key = fieldName;
				return false;
			}
		});

		// if no primary key, create primary key column
		if (!key) {
			if (!options.primaryKey) throw new Sequelize.DefinerError("Model '" + modelName + "' has no primary key defined");

			key = utils.functionValue(options.primaryKey, modelName, definition, definitions);

			if (options.primaryKeyFirst) {
				utils.unshift(fields, key, options.primaryKeyAttributes);
			} else {
				fields[key] = options.primaryKeyAttributes;
			}
		}

		definition.primaryKey = key;
		primaryKeys[modelName + utils.uppercaseFirst(key)] = primaryKeys[modelName + '_' + key] = {model: modelName, field: key};

		// get table name
		utils.defaultNoUndef(options, 'tableName', options.freezeTableName ? modelName : patches.underscoredIf(Utils.pluralize(modelName), options.underscoredAll));

		// return definition
		return definition;
	}

	function defineOne(modelName, definition)
	{
		var fields = definition.fields,
			options = definition.options;

		// populate details of fields
		_.forIn(fields, function(params, fieldName) {
			params = fields[fieldName] = _.clone(params);

			var label = fieldName;

			// process one-to-one/one-to-many associations
			var reference = params.reference;
			if (reference !== undefined && !reference) {
				delete params.reference;
				delete params.referenceKey;
			} else if (reference || (options.autoAssociate && primaryKeys[fieldName])) {
				// field references another model
				if (reference) {
					if (!definitions[reference]) throw new Sequelize.DefinerError("Referenced model '" + reference + "' in field '" + fieldName + "' does not exist");

					if (!params.referenceKey) params.referenceKey = definitions[reference].primaryKey;

					var as;
					if (_.endsWith(fieldName, utils.uppercaseFirst(params.referenceKey))) {
						as = fieldName.slice(0, -params.referenceKey.length);
						if (!params.as && as != reference) params.as = as;
						label = params.as || as;
					} else if (_.endsWith(fieldName, '_' + params.referenceKey)) {
						as = fieldName.slice(0, -params.referenceKey.length - 1);
						if (!params.as && as != reference) params.as = as;
						label = params.as || as;
					} else {
						label = reference;
					}
				} else {
					params.reference = reference = primaryKeys[fieldName].model;
					if (!params.referenceKey) params.referenceKey = primaryKeys[fieldName].field;
					label = reference;
				}

				patches.setReferences(params, {
					model: definitions[reference].options.tableName,
					key: params.referenceKey
				});

				var referenceType = utils.pop(params, 'referenceType') || 'many';
				if (['one', 'many'].indexOf(referenceType) == -1) throw new Sequelize.DefinerError("referenceType must be either 'one' or 'many' in '" + modelName + '.' + fieldName + "'");

				utils.defaultsNoUndef(params, {
					onDelete: options.onDelete,
					onUpdate: options.onUpdate
				});

				var relationshipOptions = {
					modelName1: modelName,
					modelName2: reference,
					foreignKey: fieldName,
					referenceType: 'has' + utils.uppercaseFirst(referenceType)
				};

				utils.extendNoUndef(relationshipOptions, {
					as: params.as,
					asReverse: params.asReverse,
					onDelete: params.onDelete,
					onUpdate: params.onUpdate
				});

				// set field type according to referred to field
				var referenceField = definitions[reference].fields[params.referenceKey];
				if (!referenceField) throw new Sequelize.DefinerError("referenceKey defined in '" + modelName + '.' + fieldName + "' refers to nonexistent field '" + reference + '.' + params.referenceKey + "'");

				params.type = referenceField.type;

				// store details in relationships array
				relationshipsOne.push(relationshipOptions);
			}

			// create label
			if (options.labels && !params.label) params.label = (label == 'id' ? 'ID' : utils.humanize(label));
		});

		// process manyToMany relationships
		if (definition.manyToMany) {
			_.forIn(definition.manyToMany, function(options, modelName2) {
				if (options === true) options = {};
				relationshipsMany.push(_.defaults({modelName1: modelName, modelName2: modelName2}, options));
			});
		}

		// define model in sequelize
		var defineOptions = _.clone(options);
		['primaryKey', 'primaryKeyAttributes', 'primaryKeyFirst', 'autoAssociate', 'labels', 'onDelete', 'onUpdate'].forEach(function(optionName) {
			delete defineOptions[optionName];
		});

		var model = sequelize.define(modelName, fields, defineOptions);

		// label createdAt, updatedAt, deletedAt fields
		if (options.labels) {
			['createdAt', 'updatedAt', 'deletedAt'].forEach(function(fieldName) {
				fieldName = model._timestampAttributes[fieldName];
				if (fieldName && model.attributes[fieldName]) model.attributes[fieldName].label = utils.humanize(fieldName);
			});
		}

		// done
		return model;
	}

	function defineRelationships()
	{
		// define relationships
		var models = sequelize.models;

		// define one-to-one/one-to-many relationships
		_.forEach(relationshipsOne, function(options) {
			var model1 = models[utils.pop(options, 'modelName1')],
				model2 = models[utils.pop(options, 'modelName2')];

			var asReverse = utils.pop(options, 'asReverse');

			var joinOptions = _.clone(options);
			utils.setNoUndef(joinOptions, 'as', asReverse);
			model2[options.referenceType](model1, joinOptions); // NB referenceType = 'hasOne' or 'hasMany'

			joinOptions = _.clone(options);
			model1.belongsTo(model2, options);
		});

		// define many-to-many relationships
		_.forEach(relationshipsMany, function(options) {
			utils.defaultsNoUndef(options, {
				primaryKeyFirst: defineOptions.primaryKeyFirst,
				primaryKeyThrough: defineOptions.primaryKeyThrough,
				associate: defineOptions.associateThrough,
				skipFields: defineOptions.skipFieldsOnThrough,
				labels: defineOptions.labels,
				freezeTableName: defineOptions.freezeTableName,
				underscored: defineOptions.underscored,
				underscoredAll: defineOptions.underscoredAll,
				camel: defineOptions.camelThrough,
				onDelete: defineOptions.onDelete,
				onUpdate: defineOptions.onUpdate
			});

			var modelName1 = utils.pop(options, 'modelName1'),
				modelName2 = utils.pop(options, 'modelName2'),
				model1 = models[modelName1],
				model2 = models[modelName2];

			if (!model2) throw new Sequelize.DefinerError("Model '" + modelName2 + "' referenced in many-to-many association in model '" + modelName1 + "' does not exist");
			if (modelName1 == modelName2 && (!options.as || !options.asReverse)) throw new Sequelize.DefinerError("'as' and 'asReverse' must be provided for many-to-many self-joins in model '" + modelName1 + "'");

			var key1 = definitions[modelName1].primaryKey,
				key2 = definitions[modelName2].primaryKey,
				foreignKey1 = patches.underscoredIf(modelName1 + utils.uppercaseFirst(key1), options.underscored),
				foreignKey2 = patches.underscoredIf((modelName1 == modelName2 ? Utils.singularize(options.as) : modelName2) + utils.uppercaseFirst(key2), options.underscored);

			var through, throughExisting = false;
			if (options.through) {
				// use defined through table
				through = models[options.through];
				if (!through) throw new Sequelize.DefinerError("Model '" + options.through + "' referenced as through model to '" + modelName2 + "' in many-to-many association in model '" + modelName1 + "' does not exist");

				throughExisting = true;
			} else {
				// make through table
				var fields = {};
				fields[foreignKey1] = {type: definitions[modelName1].fields[key1].type, allowNull: false, reference: null, _autoGenerated: true};
				fields[foreignKey2] = {type: definitions[modelName2].fields[key2].type, allowNull: false, reference: null, _autoGenerated: true};

				var modelNameAs = options.as ? Utils.singularize(options.as) : modelName2;
				if (options.camel) modelNameAs = utils.uppercaseFirst(modelNameAs);
				var modelName = patches.underscoredIf(modelName1 + modelNameAs, options.underscoredAll);
				var tableName = options.freezeTableName ? modelName : patches.underscoredIf(Utils.pluralize(modelName1) + Utils.pluralize(modelNameAs), options.underscoredAll);

				if (models[modelName]) throw new Sequelize.DefinerError("Through model '" + modelName + "' between '" + modelName1 + "' and '" + modelName2 + (options.as ? ' (' + options.as + ')' : '') + "' already exists");

				var throughOptions = {
					tableName: tableName,
					labels: false,
					skipFields: options.skipFields
				};

				var definition = prepOne(modelName, {fields: fields, options: throughOptions});
				through = defineOne(modelName, definition);
			}
			options.through = through;

			if (options.primaryKeyThrough) delete through.attributes[options.through.primaryKeyAttribute]._autoGenerated;

			var asReverse = utils.pop(options, 'asReverse');

			var joinOptions = _.clone(options);
			joinOptions.foreignKey = foreignKey1;
			model1.belongsToMany(model2, joinOptions);

			joinOptions = _.clone(options);
			utils.setNoUndef(joinOptions, 'as', asReverse);
			joinOptions.foreignKey = foreignKey2;
			model2.belongsToMany(model1, joinOptions);

			// move keys to first fields
			if (options.primaryKeyFirst && throughExisting) {
				var pos = options.primaryKeyThrough ? 1 : 0;
				utils.objectSplice(through.attributes, foreignKey2, utils.pop(through.attributes, foreignKey2), pos);
				utils.objectSplice(through.attributes, foreignKey1, utils.pop(through.attributes, foreignKey1), pos);
				utils.objectSplice(through.tableAttributes, foreignKey2, utils.pop(through.tableAttributes, foreignKey2), pos);
				utils.objectSplice(through.tableAttributes, foreignKey1, utils.pop(through.tableAttributes, foreignKey1), pos);
			}

			// create labels
			if (options.labels) {
				through.attributes[foreignKey1].label = utils.humanize(modelName1);
				through.attributes[foreignKey2].label = utils.humanize(modelName2);
			}

			// associate through model to dependents
			if (options.associate) {
				through.belongsTo(model1, {foreignKey: foreignKey1});
				through.belongsTo(model2, {foreignKey: foreignKey2});
				through.attributes[foreignKey1].reference = modelName1;
				through.attributes[foreignKey2].reference = modelName2;
			}
		});
	}
};
