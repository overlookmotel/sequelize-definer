// --------------------
// Sequelize definer
// Sequelize#defineAll() method
// --------------------

// modules
var _ = require('lodash');

// imports
var utils = require('./utils');

// exports

// define a set of models at once
// input expected:
//   definitions: object with names of the models as keys
//   defineOptions: options object
module.exports = function(definitions, defineOptions) {
	var sequelize = this,
		Sequelize = sequelize.Sequelize,
		Utils = Sequelize.Utils;
	
	var globalOptions = sequelize.options.define || {};
	
	defineOptions = _.extend({
		primaryKey: 'id',
		primaryKeyType: Sequelize.INTEGER,
		primaryKeyFirst: false,
		primaryKeyThrough: false,
		autoAssociate: false,
		associateThrough: false,
		//onDelete: undefined,
		//onUpdate: undefined,
		//fields: undefined,
		skipFieldsOnThrough: false,
		labels: globalOptions.labels,
		freezeTableName: globalOptions.freezeTableName,
		underscored: globalOptions.underscored,
		underscoredAll: globalOptions.underscoredAll,
		camelThrough: globalOptions.camelThrough
	}, defineOptions || {});
	
	_.defaults(defineOptions, {
		labels: false,
		freezeTableName: false,
		underscored: false,
		underscoredAll: false,
		camelThrough: false
	});
	
	// prep definitions
	var primaryKeys = {};
	
	definitions = _.mapValues(definitions, function(definition, modelName) {
		return prepOne(modelName, definition);
	});
	
	// process definitions
	var relationshipsOne = [];
	var relationshipsMany = [];
	
	_.forIn(definitions, function(definition, modelName) {
		defineOne(modelName, definition);
	});
	
	// create relationships
	defineRelationships();
	
	// return sequelize (for chaining)
	return sequelize;
	
	// ----------
	// functions
	
	function prepOne(modelName, definition)
	{
		definition = _.clone(definition);
		
		// inherit options from defineOptions (except fields and through-related options)
		var fields = definition.fields = _.clone(definition.fields || {}),
			options = definition.options = _.clone(definition.options || {});
		
		utils.defaultsNoUndef(options, defineOptions);
		['fields', 'associateThrough', 'skipFieldsOnThrough', 'camelThrough'].forEach(function(fieldName) {
			delete options[fieldName];
		});
		
		// add additional fields
		if (defineOptions.fields && !options.skipFields) {
			_.forIn(defineOptions.fields, function(field, fieldName) {
				if (fields[fieldName] !== undefined) return;
				fields[fieldName] = utils.functionValue(_.clone(field), modelName, definition, definitions);
			});
		}
		
		// delete empty fields and set field type where shorthand definition used
		_.forIn(fields, function(field, fieldName) {
			if (!field) {
				delete fields[fieldName];
			} else if (!_.isPlainObject(field)) {
				fields[fieldName] = {type: field};
			}
		});
		
		// find primary key
		var key;
		_.forIn(fields, function(field, fieldName) {
			if (field.primaryKey) {
				key = fieldName;
				return false;
			}
		});
		
		// if no primary key, create primary key column
		if (!key) {
			if (!options.primaryKey) throw new Sequelize.SequelizeDefinerError("Model '" + modelName + "' has no primary key defined");
			
			key = utils.functionValue(options.primaryKey, modelName, definition, definitions);
			var shouldAutoIncrement = options.primaryKeyType.indexOf('INTEGER') !== -1 || options.primaryKeyType.indexOf('BIGINT') !== -1;
			var keyField = {type: options.primaryKeyType, allowNull: false, primaryKey: true, autoIncrement: shouldAutoIncrement, _autoGenerated: true};
			
			if (options.primaryKeyFirst) {
				utils.unshift(fields, key, keyField);
			} else {
				fields[key] = keyField;
			}
		}
		
		definition.primaryKey = key;
		primaryKeys[Utils._.underscoredIf(modelName + Utils.uppercaseFirst(key), defineOptions.underscored)] = {model: modelName, field: key};
		
		// get table name
		utils.defaultNoUndef(options, 'tableName', options.freezeTableName ? modelName : Utils._.underscoredIf(Utils.pluralize(modelName), options.underscoredAll));
		
		// return definition
		return definition;
	}
	
	function defineOne(modelName, definition)
	{
		var fields = definition.fields,
			options = definition.options;
		
		// populate details of fields
		_.forIn(fields, function(params, fieldName) {
			params = fields[fieldName] = _.clone(params);
			
			var label = fieldName;
			
			// process one-to-one/one-to-many associations
			var reference = params.reference;
			if (reference !== undefined && !reference) {
				delete params.reference;
			} else if (reference || (options.autoAssociate && primaryKeys[fieldName])) {
				// field references another model
				if (reference) {
					if (!definitions[reference]) throw new Sequelize.SequelizeDefinerError("Referenced model '" + reference + "' in field '" + fieldName + "' does not exist");
					
					if (!params.referencesKey) params.referencesKey = definitions[reference].primaryKey;
					
					if (utils.endsWith(fieldName, Utils.uppercaseFirst(params.referencesKey))) {
						var as = fieldName.slice(0, -params.referencesKey.length);
						if (!params.as && as != reference) params.as = as;
						label = params.as || as;
					} else {
						label = reference;
					}
				} else {
					params.reference = reference = primaryKeys[fieldName].model;
					if (!params.referencesKey) params.referencesKey = primaryKeys[fieldName].field;
					label = reference;
				}
				
				params.references = definitions[reference].options.tableName;
				
				var referenceType = utils.pop(params, 'referenceType') || 'many';
				if (['one', 'many'].indexOf(referenceType) == -1) throw new Sequelize.SequelizeDefinerError("referenceType must be either 'one' or 'many' in '" + modelName + '.' + fieldName + "'");
				
				utils.defaultsNoUndef(params, {
					onDelete: options.onDelete,
					onUpdate: options.onUpdate
				});
				
				var relationshipOptions = {
					modelName1: modelName,
					modelName2: reference,
					foreignKey: fieldName,
					referenceType: 'has' + Utils.uppercaseFirst(referenceType)
				};
				
				utils.extendNoUndef(relationshipOptions, {
					as: params.as,
					asReverse: params.asReverse,
					onDelete: params.onDelete,
					onUpdate: params.onUpdate
				});
				
				// set field type according to referred to field
				var referenceField = definitions[reference].fields[params.referencesKey];
				if (!referenceField) throw new Sequelize.SequelizeDefinerError("referenceKey defined in '" + modelName + '.' + fieldName + "' refers to nonexistent field '" + reference + '.' + params.referencesKey + "'");
				
				params.type = referenceField.type;
				
				// store details in relationships array
				relationshipsOne.push(relationshipOptions);
			}
			
			// create label
			if (options.labels && !params.label) params.label = (label == 'id' ? 'ID' : utils.humanize(label));
		});
		
		// process manyToMany relationships
		if (definition.manyToMany) {
			_.forIn(definition.manyToMany, function(options, modelName2) {
				if (options === true) options = {};
				relationshipsMany.push(_.defaults({modelName1: modelName, modelName2: modelName2}, options));
			});
		}
		
		// define model in sequelize
		var defineOptions = _.clone(options);
		['primaryKey', 'primaryKeyType', 'primaryKeyFirst', 'autoAssociate', 'labels', 'onDelete', 'onUpdate'].forEach(function(optionName) {
			delete defineOptions[optionName];
		});
		
		var model = sequelize.define(modelName, fields, defineOptions);
		
		// label createdAt, updatedAt, deletedAt fields
		if (options.labels) {
			['createdAt', 'updatedAt', 'deletedAt'].forEach(function(fieldName) {
				fieldName = model.options[fieldName];
				if (model.attributes[fieldName]) model.attributes[fieldName].label = utils.humanize(fieldName);
			});
		}
		
		// done
		return model;
	}
	
	function defineRelationships()
	{
		// define relationships
		var models = sequelize.models;
		
		// define one-to-one/one-to-many relationships
		_.forEach(relationshipsOne, function(options) {
			var model1 = models[utils.pop(options, 'modelName1')],
				model2 = models[utils.pop(options, 'modelName2')];
			
			var asReverse = utils.pop(options, 'asReverse');
			
			var joinOptions = _.clone(options);
			utils.setNoUndef(joinOptions, 'as', asReverse);
			model2[options.referenceType](model1, joinOptions); // NB referenceType = 'hasOne' or 'hasMany'
			
			joinOptions = _.clone(options);
			model1.belongsTo(model2, options);
		});
		
		// define many-to-many relationships
		_.forEach(relationshipsMany, function(options) {
			utils.defaultsNoUndef(options, {
				primaryKeyFirst: defineOptions.primaryKeyFirst,
				primaryKeyThrough: defineOptions.primaryKeyThrough,
				associate: defineOptions.associateThrough,
				skipFields: defineOptions.skipFieldsOnThrough,
				labels: defineOptions.labels,
				freezeTableName: defineOptions.freezeTableName,
				underscored: defineOptions.underscored,
				underscoredAll: defineOptions.underscoredAll,
				camel: defineOptions.camelThrough,
				onDelete: defineOptions.onDelete,
				onUpdate: defineOptions.onUpdate
			});
			
			var modelName1 = utils.pop(options, 'modelName1'),
				modelName2 = utils.pop(options, 'modelName2'),
				model1 = models[modelName1],
				model2 = models[modelName2],
				key1 = definitions[modelName1].primaryKey,
				key2 = definitions[modelName2].primaryKey,
				foreignKey1 = Utils._.underscoredIf(modelName1 + Utils.uppercaseFirst(key1), options.underscored),
				foreignKey2 = Utils._.underscoredIf(modelName2 + Utils.uppercaseFirst(key2), options.underscored);
			
			var throughExisting = false;
			if (options.through) {
				// use defined through table
				options.through = models[options.through];
				
				throughExisting = true;
			} else {
				// make through table
				var fields = {};
				fields[foreignKey1] = {type: definitions[modelName1].fields[key1].type, allowNull: false, reference: null, _autoGenerated: true};
				fields[foreignKey2] = {type: definitions[modelName2].fields[key2].type, allowNull: false, reference: null, _autoGenerated: true};
				
				var modelNameAs = options.as ? Utils.singularize(options.as) : modelName2;
				if (options.camel) modelNameAs = Utils.uppercaseFirst(modelNameAs);
				var modelName = Utils._.underscoredIf(modelName1 + modelNameAs, options.underscoredAll);
				var tableName = options.freezeTableName ? modelName : Utils._.underscoredIf(Utils.pluralize(modelName1) + Utils.pluralize(modelNameAs), options.underscoredAll);
				
				if (models[modelName]) throw new Sequelize.SequelizeDefinerError("Through model '" + modelName + "' between '" + modelName1 + "' and '" + modelName2 + (options.as ? ' (' + options.as + ')' : '') + "' already exists");
				
				var throughOptions = {
					tableName: tableName,
					labels: false,
					skipFields: options.skipFields
				};
				
				var definition = prepOne(modelName, {fields: fields, options: throughOptions});
				options.through = defineOne(modelName, definition);
			}
			
			if (options.primaryKeyThrough) delete options.through.attributes[options.through.primaryKeyAttribute]._autoGenerated;
			
			var asReverse = utils.pop(options, 'asReverse');
			
			var joinOptions = _.clone(options);
			joinOptions.foreignKey = foreignKey1;
			model1.hasMany(model2, joinOptions);
			
			joinOptions = _.clone(options);
			utils.setNoUndef(joinOptions, 'as', asReverse);
			joinOptions.foreignKey = foreignKey2;
			model2.hasMany(model1, joinOptions);
			
			// move keys to first fields
			var through = options.through;
			if (options.primaryKeyFirst && throughExisting) {
				var pos = options.primaryKeyThrough ? 1 : 0;
				utils.objectSplice(through.attributes, foreignKey2, utils.pop(through.attributes, foreignKey2), pos);
				utils.objectSplice(through.attributes, foreignKey1, utils.pop(through.attributes, foreignKey1), pos);
				utils.objectSplice(through.tableAttributes, foreignKey2, utils.pop(through.tableAttributes, foreignKey2), pos);
				utils.objectSplice(through.tableAttributes, foreignKey1, utils.pop(through.tableAttributes, foreignKey1), pos);
			}
			
			// create labels
			if (options.labels) {
				through.attributes[foreignKey1].label = utils.humanize(modelName1);
				through.attributes[foreignKey2].label = utils.humanize(modelName2);
			}
			
			// associate through model to dependents
			if (options.associate) {
				through.belongsTo(model1, {foreignKey: foreignKey1});
				through.belongsTo(model2, {foreignKey: foreignKey2});
				through.attributes[foreignKey1].reference = modelName1;
				through.attributes[foreignKey2].reference = modelName2;
			}
		});
	}
};
