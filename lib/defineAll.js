/* --------------------
 * sequelize-definer module
 * Sequelize#defineAll() method
 * ------------------*/

'use strict';

// Modules
const _ = require('lodash');

// Imports
const utils = require('./utils.js'),
	patchesFn = require('./patches.js');

// Exports

/**
 * Define a set of models at once.
 * Called as `sequelize.defineAll()`.
 * @param {Array<object>} definitions - Object with names of the models as keys
 * @param {Object} [defineOptions] - Options object
 * @returns {Object} - Sequelize instance
 */
module.exports = function(definitions, defineOptions) {
	const sequelize = this,
		{Sequelize} = sequelize,
		{Utils} = Sequelize,
		patches = patchesFn(Sequelize);

	const globalOptions = sequelize.options.define || {};

	defineOptions = _.extend({
		primaryKey: 'id',
		primaryKeyAttributes: {},
		primaryKeyFirst: false,
		primaryKeyThrough: false,
		autoAssociate: false,
		associateThrough: false,
		// onDelete: undefined,
		// onUpdate: undefined,
		// fields: undefined,
		skipFieldsOnThrough: false,
		labels: globalOptions.labels || false,
		freezeTableName: globalOptions.freezeTableName || false,
		lowercaseTableName: globalOptions.lowercaseTableName || false,
		underscored: globalOptions.underscored || false,
		underscoredAll: globalOptions.underscoredAll || false,
		camelThrough: globalOptions.camelThrough || false
	}, defineOptions || {});

	if (defineOptions.primaryKeyType) {
		defineOptions.primaryKeyAttributes.type = defineOptions.primaryKeyType;
		delete defineOptions.primaryKeyType;
	} else {
		defineOptions.primaryKeyAttributes.type = Sequelize.INTEGER;
	}

	// Prep definitions
	const primaryKeys = {};

	definitions = _.mapValues(definitions, (definition, modelName) => prepOne(modelName, definition));

	// Process definitions
	const relationshipsOne = [];
	const relationshipsMany = [];

	_.forIn(definitions, (definition, modelName) => {
		defineOne(modelName, definition);
	});

	// Create relationships
	defineRelationships();

	// Return sequelize instance (for chaining)
	return sequelize;

	/*
	 * Functions
	 */

	function prepOne(modelName, definition) {
		definition = _.clone(definition);

		// Inherit options from defineOptions (except fields and through-related options)
		const fields = _.clone(definition.fields || {}),
			options = _.clone(definition.options || {});
		definition.fields = fields;
		definition.options = options;

		utils.defaultsNoUndef(options, defineOptions);
		['fields', 'associateThrough', 'skipFieldsOnThrough', 'camelThrough'].forEach((fieldName) => {
			delete options[fieldName];
		});

		if (options.primaryKeyType) {
			options.primaryKeyAttributes.type = options.primaryKeyType;
			delete options.primaryKeyType;
		}

		options.primaryKeyAttributes = _.defaults({
			primaryKey: true,
			_autoGenerated: true
		}, options.primaryKeyAttributes, defineOptions.primaryKeyAttributes, {
			allowNull: false
		});

		if (
			[Sequelize.INTEGER.key, Sequelize.BIGINT.key]
				.includes(options.primaryKeyAttributes.type.key)
		) {
			options.primaryKeyAttributes.autoIncrement = true;
		}
		if (
			options.primaryKeyAttributes.type.key === Sequelize.UUID.key
			&& !options.primaryKeyAttributes.defaultValue
		) {
			options.primaryKeyAttributes.defaultValue = Sequelize.UUIDV4;
		}

		// Add additional fields
		if (defineOptions.fields && !options.skipFields) {
			_.forIn(defineOptions.fields, (field, fieldName) => {
				if (fields[fieldName] !== undefined) return;
				field = utils.functionValue(field, modelName, definition, definitions);
				if (field instanceof Sequelize.ABSTRACT) field = {type: field};
				fields[fieldName] = _.clone(field);
			});
		}

		// Delete empty fields and set field type where shorthand definition used
		_.forIn(fields, (field, fieldName) => {
			if (!field) {
				delete fields[fieldName];
			} else if (!_.isPlainObject(field)) {
				fields[fieldName] = {type: field};
			}
		});

		// Find primary key
		let key;
		_.forIn(fields, (field, fieldName) => { // eslint-disable-line consistent-return
			if (field.primaryKey) {
				key = fieldName;
				return false;
			}
		});

		// If no primary key, create primary key column
		if (!key) {
			if (!options.primaryKey) {
				throw new Sequelize.DefinerError(`Model '${modelName}' has no primary key defined`);
			}

			key = utils.functionValue(options.primaryKey, modelName, definition, definitions);

			if (options.primaryKeyFirst) {
				utils.unshift(fields, key, options.primaryKeyAttributes);
			} else {
				fields[key] = options.primaryKeyAttributes;
			}
		}

		definition.primaryKey = key;
		const primaryKeyDef = {model: modelName, field: key};
		primaryKeys[modelName + utils.uppercaseFirst(key)] = primaryKeyDef;
		primaryKeys[utils.lowercaseFirst(modelName) + utils.uppercaseFirst(key)] = primaryKeyDef;
		primaryKeys[`${modelName}_${key}`] = primaryKeyDef;
		primaryKeys[`${utils.lowercaseFirst(modelName)}_${key}`] = primaryKeyDef;

		// Get table name
		if (!options.tableName) {
			options.tableName = options.freezeTableName ? modelName : makeTableName(modelName, options);
		}

		// Return definition
		return definition;
	}

	function defineOne(modelName, definition) {
		const {fields, options} = definition;

		// Populate details of fields
		_.forIn(fields, (params, fieldName) => {
			params = _.clone(params);
			fields[fieldName] = params;

			let label = fieldName;

			// Process one-to-one/one-to-many associations
			let {reference} = params;
			if (reference !== undefined && !reference) {
				delete params.reference;
				delete params.referenceKey;
			} else if (reference || (options.autoAssociate && primaryKeys[fieldName])) {
				// Field references another model
				if (reference) {
					if (!definitions[reference]) {
						throw new Sequelize.DefinerError(
							`Referenced model '${reference}' in field '${fieldName}' does not exist`
						);
					}

					if (!params.referenceKey) params.referenceKey = definitions[reference].primaryKey;

					let as;
					if (_.endsWith(fieldName, utils.uppercaseFirst(params.referenceKey))) {
						as = fieldName.slice(0, -params.referenceKey.length);
						if (!params.as && as !== reference) params.as = as;
						label = params.as || as;
					} else if (_.endsWith(fieldName, `_${params.referenceKey}`)) {
						as = fieldName.slice(0, -params.referenceKey.length - 1);
						if (!params.as && as !== reference) params.as = as;
						label = params.as || as;
					} else {
						label = reference;
					}
				} else {
					reference = primaryKeys[fieldName].model;
					params.reference = reference;
					if (!params.referenceKey) params.referenceKey = primaryKeys[fieldName].field;
					label = reference;
				}

				patches.setReferences(params, {
					model: definitions[reference].options.tableName,
					key: params.referenceKey
				});

				const referenceType = utils.pop(params, 'referenceType') || 'many';
				if (!['one', 'many'].includes(referenceType)) {
					throw new Sequelize.DefinerError(
						`referenceType must be either 'one' or 'many' in '${modelName}.${fieldName}'`
					);
				}

				utils.defaultsNoUndef(params, {
					onDelete: options.onDelete,
					onUpdate: options.onUpdate
				});

				const relationshipOptions = {
					modelName1: modelName,
					modelName2: reference,
					foreignKey: fieldName,
					referenceType: `has${utils.uppercaseFirst(referenceType)}`
				};

				utils.extendNoUndef(relationshipOptions, {
					as: params.as,
					asReverse: params.asReverse,
					onDelete: params.onDelete,
					onUpdate: params.onUpdate
				});

				// Set field type according to referred to field
				const referenceField = definitions[reference].fields[params.referenceKey];
				if (!referenceField) {
					throw new Sequelize.DefinerError(
						`referenceKey defined in '${modelName}.${fieldName}' refers to `
						+ `nonexistent field '${reference}.${params.referenceKey}'`
					);
				}

				params.type = referenceField.type;

				// Store details in relationships array
				relationshipsOne.push(relationshipOptions);
			}

			// Create label
			if (options.labels && !params.label) {
				params.label = (label === 'id' ? 'ID' : utils.humanize(label));
			}
		});

		// Process many-to-many relationships
		if (definition.manyToMany) {
			_.forIn(definition.manyToMany, (opts, modelName2) => {
				if (opts === true) opts = {};
				relationshipsMany.push(_.defaults({modelName1: modelName, modelName2}, opts));
			});
		}

		// Define model in sequelize
		const defineOptions = _.clone(options); // eslint-disable-line no-shadow
		[
			'primaryKey', 'primaryKeyAttributes', 'primaryKeyFirst',
			'autoAssociate', 'labels', 'onDelete', 'onUpdate'
		].forEach((optionName) => {
			delete defineOptions[optionName];
		});

		const model = sequelize.define(modelName, fields, defineOptions);

		// Label createdAt, updatedAt, deletedAt fields
		if (options.labels) {
			['createdAt', 'updatedAt', 'deletedAt'].forEach((fieldName) => {
				fieldName = model._timestampAttributes[fieldName];
				if (fieldName && model.rawAttributes[fieldName]) {
					model.rawAttributes[fieldName].label = utils.humanize(fieldName);
				}
			});
		}

		// Done
		return model;
	}

	function defineRelationships() {
		// Define relationships
		const {models} = sequelize;

		// Define one-to-one/one-to-many relationships
		_.forEach(relationshipsOne, (options) => {
			const model1 = models[utils.pop(options, 'modelName1')],
				model2 = models[utils.pop(options, 'modelName2')];

			const asReverse = utils.pop(options, 'asReverse');

			let joinOptions = _.clone(options);
			utils.setNoUndef(joinOptions, 'as', asReverse);
			// NB referenceType = 'hasOne' or 'hasMany'
			model2[options.referenceType](model1, joinOptions);

			joinOptions = _.clone(options);
			model1.belongsTo(model2, options);
		});

		// Define many-to-many relationships
		_.forEach(relationshipsMany, (options) => {
			utils.defaultsNoUndef(options, {
				primaryKeyFirst: defineOptions.primaryKeyFirst,
				primaryKeyThrough: defineOptions.primaryKeyThrough,
				associate: defineOptions.associateThrough,
				skipFields: defineOptions.skipFieldsOnThrough,
				labels: defineOptions.labels,
				freezeTableName: defineOptions.freezeTableName,
				lowercaseTableName: defineOptions.lowercaseTableName,
				underscored: defineOptions.underscored,
				underscoredAll: defineOptions.underscoredAll,
				camel: defineOptions.camelThrough,
				onDelete: defineOptions.onDelete,
				onUpdate: defineOptions.onUpdate
			});

			const modelName1 = utils.pop(options, 'modelName1'),
				modelName2 = utils.pop(options, 'modelName2'),
				model1 = models[modelName1],
				model2 = models[modelName2];

			if (!model2) {
				throw new Sequelize.DefinerError(
					`Model '${modelName2}' referenced in many-to-many association `
					+ `in model '${modelName1}' does not exist`
				);
			}
			if (modelName1 === modelName2 && (!options.as || !options.asReverse)) {
				throw new Sequelize.DefinerError(
					`'as' and 'asReverse' must be provided for many-to-many self-joins in model '${modelName1}'`
				);
			}

			const key1 = definitions[modelName1].primaryKey,
				key2 = definitions[modelName2].primaryKey,
				foreignKey1 = patches.underscoredIf(
					`${modelName1}${utils.uppercaseFirst(key1)}`,
					options.underscored
				),
				foreignKey2 = patches.underscoredIf(
					(modelName1 === modelName2 ? Utils.singularize(options.as) : modelName2)
						+ utils.uppercaseFirst(key2),
					options.underscored
				);

			let through,
				throughExisting = false;
			if (options.through) {
				// Use defined through table
				through = models[options.through];
				if (!through) {
					throw new Sequelize.DefinerError(
						`Model '${options.through}' referenced as through model to '${modelName2}' `
						+ `in many-to-many association in model '${modelName1}' does not exist`
					);
				}

				throughExisting = true;
			} else {
				// Make through table
				const fields = {};
				fields[foreignKey1] = {
					type: definitions[modelName1].fields[key1].type,
					allowNull: false,
					reference: null,
					_autoGenerated: true
				};
				fields[foreignKey2] = {
					type: definitions[modelName2].fields[key2].type,
					allowNull: false,
					reference: null,
					_autoGenerated: true
				};

				let modelNameAs = options.as ? Utils.singularize(options.as) : modelName2;
				if (options.camel) modelNameAs = utils.uppercaseFirst(modelNameAs);
				const modelName = patches.underscoredIf(
					`${modelName1}${modelNameAs}`,
					options.underscoredAll
				);
				const tableName = options.tableName || (
					options.freezeTableName
						? modelName
						: makeTableName(Utils.pluralize(modelName1) + modelNameAs, options)
				);

				if (models[modelName]) {
					throw new Sequelize.DefinerError(
						`Through model '${modelName}' between '${modelName1}' and `
						+ `'${modelName2}${options.as ? ` (${options.as})` : ''}' already exists`
					);
				}

				const throughOptions = {
					tableName,
					labels: false,
					skipFields: options.skipFields
				};

				const definition = prepOne(modelName, {fields, options: throughOptions});
				through = defineOne(modelName, definition);
			}
			options.through = through;

			if (options.primaryKeyThrough) {
				delete through.rawAttributes[options.through.primaryKeyAttribute]._autoGenerated;
			}

			const asReverse = utils.pop(options, 'asReverse');

			let joinOptions = _.clone(options);
			joinOptions.foreignKey = foreignKey1;
			model1.belongsToMany(model2, joinOptions);

			joinOptions = _.clone(options);
			utils.setNoUndef(joinOptions, 'as', asReverse);
			joinOptions.foreignKey = foreignKey2;
			model2.belongsToMany(model1, joinOptions);

			// Move keys to first fields
			if (options.primaryKeyFirst && throughExisting) {
				const pos = options.primaryKeyThrough ? 1 : 0;
				utils.objectSplice(
					through.attributes, foreignKey2, utils.pop(through.attributes, foreignKey2), pos
				);
				utils.objectSplice(
					through.attributes, foreignKey1, utils.pop(through.attributes, foreignKey1), pos
				);
				utils.objectSplice(
					through.tableAttributes,
					foreignKey2,
					utils.pop(through.tableAttributes, foreignKey2),
					pos
				);
				utils.objectSplice(
					through.tableAttributes,
					foreignKey1,
					utils.pop(through.tableAttributes, foreignKey1),
					pos
				);
			}

			// Create labels
			if (options.labels) {
				through.attributes[foreignKey1].label = utils.humanize(modelName1);
				through.attributes[foreignKey2].label = utils.humanize(modelName2);
			}

			// Associate through model to dependents
			if (options.associate) {
				through.belongsTo(model1, {foreignKey: foreignKey1});
				through.belongsTo(model2, {foreignKey: foreignKey2});
				through.rawAttributes[foreignKey1].reference = modelName1;
				through.rawAttributes[foreignKey2].reference = modelName2;
			}
		});
	}

	function makeTableName(modelName, options) {
		let tableName = modelName;
		if (options.lowercaseTableName) tableName = utils.lowercaseFirst(tableName);
		return patches.underscoredIf(Utils.pluralize(tableName), options.underscoredAll);
	}
};
